#version 330 core
precision mediump float;

//此shader作为测试带模糊边缘的聚光灯效果

//观察者在世界空间的位置，即摄像机的位置
uniform vec3 viewPos;

//法向量
varying vec3 Normal;
//物体在世界空间的坐标
varying vec3 FragPos;
//纹理坐标
varying vec2 TexCoords;

struct Material
{
    sampler2D diffuse;
    sampler2D specular;
    float shininess;
};
uniform Material material;

struct Light
{
    //vec3 position;//光源的位置
	//vec3 direction;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
	
	//光照衰减相关
	float constant;
    float linear;
    float quadratic;
	
	//聚光灯效果
	vec3 position;
    vec3 direction;
    float cutOff;
	float outerCutOff;
};
uniform Light light;


void main()
{
	vec3 lightDir = normalize(light.position-FragPos);
	
	float theta = dot(lightDir,normalize(-light.direction));
	float amy = light.outerCutOff - light.cutOff;
	float intensity = clamp((light.outerCutOff-theta)/amy,0.0,1.0);
	
	
	//计算环境环境光照影响
	vec3 ambient = light.ambient * vec3(texture2D(material.diffuse, TexCoords));
	
	//计算漫反射光照影响
	vec3 norm = normalize(Normal);
	
	float diff = max(dot(norm,lightDir),0.0);
	vec3 diffLightColor = light.diffuse * (diff * vec3(texture2D(material.diffuse,TexCoords)));
	
	//计算镜面反射镜像，三个光照影响组成冯氏光照效果
	
	//计算反射坐标
	vec3 viewDir = normalize(viewPos - FragPos);
	vec3 reflectDir = reflect(-lightDir, norm);
	//计算镜面亮度分量
	float spec = pow(max(dot(viewDir,reflectDir),0.0),material.shininess);
	//vec3 specular = light.specular * (spec * (vec3(1.0)-vec3(texture2D(material.specular,TexCoords))));
	vec3 specular = light.specular * (spec * vec3(texture2D(material.specular,TexCoords)));
	
	
	//计算距离对光照的衰减影响
	float length = length(light.position - FragPos);
	float attenuation = 1.0/(light.constant + light.linear*length + light.quadratic*length);
	
	//光照效果叠加为最后效果
	gl_FragColor = vec4((ambient*attenuation + diffLightColor*attenuation*intensity+specular*attenuation*intensity),1.0);
}