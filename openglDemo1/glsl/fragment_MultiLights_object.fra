#version 330 core
precision mediump float;

//此shader将所有灯光效果全部写在一起，并把灯光效果的实现在glsl用函数封装

//观察者在世界空间的位置，即摄像机的位置
uniform vec3 viewPos;

//法向量
varying vec3 Normal;
//物体在世界空间的坐标
varying vec3 FragPos;
//纹理坐标
varying vec2 TexCoords;

struct Material
{
    sampler2D diffuse;
    sampler2D specular;
    float shininess;
};
uniform Material material;



struct DirLight
{
  vec3 direction;
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};
uniform DirLight dirLight;

//平行光照影响函数
vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir)
{
	vec3 lightDir = normalize(-light.direction);
	 // 计算漫反射强度
	float diff = max(dot(normal,lightDir),0.0);
	// 计算镜面反射强度
	vec3 reflectDir = reflect(-lightDir,normal);
	float spec = pow(max(dot(viewDir,reflectDir),0.0),material.shininess);
	 // 合并各个光照分量
	vec3 ambient = light.ambient * vec3(texture2D(material.diffuse, TexCoords));
	vec3 diffuse = light.diffuse * (diff *  vec3(texture2D(material.diffuse, TexCoords)));
	vec3 specular = light.specular * (spec*vec3(texture2D(material.specular,TexCoords)));
	
	return ambient + diffuse + specular;
}

//点光源
struct PointLight {
    vec3 position;

    float constant;
    float linear;
    float quadratic;  

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};  
#define NR_POINT_LIGHTS 4
uniform PointLight pointLights[NR_POINT_LIGHTS];

vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)
{
	 vec3 lightDir = normalize(light.position - fragPos);
    // 计算漫反射强度
    float diff = max(dot(normal, lightDir), 0.0);
    // 计算镜面反射
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // 计算衰减
    float distance    = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance +
                 light.quadratic * (distance * distance));
    // 将各个分量合并
    vec3 ambient  = light.ambient  * vec3(texture2D(material.diffuse, TexCoords));
    vec3 diffuse  = light.diffuse  * diff * vec3(texture2D(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture2D(material.specular, TexCoords));
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
    return (ambient + diffuse + specular);
}

//聚光灯  笔记本的显卡uniform个数不够，运行时会报错
 struct Spotlight
{
	vec3 position;
	vec3 direction;
	float cutOff;
	float outerCutOff;
	
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	
	float constant;
	float linear;
	float quadratic;
};
uniform Spotlight spotLight;

vec3 CalcSpotLight(Spotlight light,vec3 normal,vec3 fragPos,vec3 viewDir)
{
	 vec3 lightDir = normalize(light.position - fragPos);
	 float theta = dot(lightDir,normalize(-light.direction));
	 float amy = light.outerCutOff - light.cutOff;
	 float intensity = clamp((light.outerCutOff - theta)/amy,0.0,1.0);
	 
    // 计算漫反射强度
    float diff = max(dot(normal, lightDir), 0.0);
    // 计算镜面反射
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
    // 计算衰减
    float distance    = length(light.position - fragPos);
    float attenuation = 1.0 / (light.constant + light.linear * distance +
                 light.quadratic * (distance * distance));
    // 将各个分量合并
    vec3 ambient  = light.ambient  * vec3(texture2D(material.diffuse, TexCoords));
    vec3 diffuse  = light.diffuse  * diff * vec3(texture2D(material.diffuse, TexCoords));
    vec3 specular = light.specular * spec * vec3(texture2D(material.specular, TexCoords));
    ambient  *= attenuation;
    diffuse  *= attenuation;
    specular *= attenuation;
	
	diffuse *= intensity;
	specular *= intensity;
	
	return ambient+diffuse+specular;
} 


void main()
{
	 // 一些属性
    vec3 norm = normalize(Normal);
    vec3 viewDir = normalize(viewPos - FragPos);

    // 第一步，计算平行光照
    vec3 result = CalcDirLight(dirLight, norm, viewDir);
    // 第二步，计算顶点光照
    for(int i = 0; i < NR_POINT_LIGHTS; i++)
        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);
    // 第三部，计算 Spot light
    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);
	
	//光照效果叠加为最后效果
	gl_FragColor = vec4(result,1.0);
}